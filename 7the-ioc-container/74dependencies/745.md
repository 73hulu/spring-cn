Spring容器可以自动连接协作bean之间的关系。 您可以通过检查ApplicationContext的内容，允许Spring自动为您的bean解析协作者（其他bean）。自动装配具有以下优点：

* 自动装配可以显著减少指定属性或构造函数参数的需要。（在本章其他地方讨论的其他机制，如bean模板，在这方面也很有价值[discussed elsewhere in this chapter](https://docs.spring.io/spring/docs/4.3.20.RELEASE/spring-framework-reference/htmlsingle/#beans-child-bean-definitions)）。
* 自动连接可以随着对象的发展而更新配置。例如，如果需要向类添加依赖项，则无需修改配置即可自动满足该依赖项。因此，自动连接在开发过程中特别有用，当代码库变得更加稳定时，它不会否定当前库，并切换到显式连接的选项。

使用基于XML的配置元数据[\[2\]](https://docs.spring.io/spring/docs/4.3.20.RELEASE/spring-framework-reference/htmlsingle/#ftn.d5e2674)时，可以使用&lt;bean /&gt;元素的autowire属性为bean定义指定autowire模式。自动装配功能有四种模式。 您指定每个bean的自动装配，因此可以选择要自动装配的那些。

表7.2     自动装配模式

| Mode | Explanation |
| :--- | :--- |
| no | （默认）无自动装配。必须通过ref元素定义Bean引用。不建议对较大的部署更改默认设置，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了系统的结构。 |
| byName | 按属性名称自动装配。 Spring查找与需要自动装配的属性同名的bean。例如，如果bean定义按名称设置为autowire，并且它包含master属性（即，它具有setMaster（..） 方法），Spring查找名为master的bean定义，并使用它来设置属性。 |
| byType | 如果容器中只存在一个属性类型的bean，则允许自动装配属性。 如果存在多个，则抛出致命异常，这表示您不能对该bean使用byType自动装配。如果没有匹配的bean，什么也不会发生;属性未设置。 |
| constructor | 类似于byType，但适用于构造函数参数。如果容器中没有构造函数参数类型的一个bean，则会引发致命错误。 |

使用byType或构造函数自动装配模式，您可以连接数组和类型集合。在这种情况下，提供容器内与预期类型匹配的所有autowire候选者以满足依赖性。如果预期的键类型为String，则可以自动装配强类型映射。自动装配的Maps值将包含与预期类型匹配的所有Bean实例，而Maps键将包含相应的bean名称。

您可以将autowire行为与依赖关系检查结合起来，这是在自动装配完成后执行的。

#### Limitations and disadvantages of autowiring----自动装配的局限和缺点

自动装配在项目中一致使用时效果最佳。 如果一般不使用自动装配，那么开发人员使用它来连接一个或两个bean定义可能会让人感到困惑。

考虑自动装配的局限和缺点：

* property和constructor-arg设置中的显式依赖项始终覆盖自动装配。您无法自动装配所谓的简单属性，例如基元，字符串和类（以及此类简单属性的数组）。 这种限制是附加设计的。
* 自动装配不如显式布线精确。 虽然如上表所示，Spring会小心避免在可能产生意外结果的歧义的情况下进行猜测，但不再明确记录Spring管理对象之间的关系。
* 从Spring容器生成文档的工具可能无法使用连接信息。
* 容器中的多个bean定义可能与要自动装配的setter方法或构造函数参数指定的类型匹配。 对于数组，集合或Maps，这不一定是个问题。 但是，对于期望单个值的依赖关系，这种模糊性不是任意解决的。 如果没有可用的唯一bean定义，则抛出异常。



